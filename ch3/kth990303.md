## 레디스 기본 개념
3장에서는 레디스 자료구조에 대해 전반적으로 쭉 소개하는 것으로 이해했습니다.
요약 위주보단, 관련있는 사례 및 포스팅 읽으면서 느낀점과 의문 정리하는 방식으로 해볼게요.

---

### 사이드프로젝트에서 레디스 조작 사례
- **상황**

모카콩 사이드프로젝트에서, 운영 환경에 있는 특정 카페의 리뷰 데이터를 삭제해야 되는 요구사항이 주어졌습니다.

- **접근방법**

운영 환경이긴 하지만, 트래픽이 많지 않으며 올바르지 않은 테스트용 데이터가 들어간 상황이었습니다. 이에 따라 직접 해당 cafe의 review 데이터를 `delete` 쿼리로 삭제해주었습니다.

- **문제**

해당 데이터를 delete 쿼리로 삭제 후 commit했음에도 불구하고, 앱에서 **해당 카페의 리뷰 데이터가 미리보기로 계속 잘 조회되는 현상**이 발생했습니다.

- **문제 해결 접근 방법**

`keys *` 명령어는 키 전체 조회하므로 느린 성능을 가집니다. 이에 따라 `scan 0` 명령어로 캐시 데이터를 조회했으나, 리뷰 관련 캐시가 조회되지 않아 캐시데이터가 없는 것으로 판단**했었습**니다.

<img width="484" alt="image" src="https://github.com/TReKa-Genius-Library/redis-for-developer/assets/57135043/f26ad65b-8811-41ce-92a3-b8f10d533496">

들뜬 바보...

하지만, 혹시 몰라 `keys *` 명령어로 전체 조회를 해보았고 약 200개 정도의 캐시데이터가 조회됐습니다.
(200개 정도 조회하는 데 걸린 시간은 0.1초가 채 안되는 것으로 확인)
진작 `keys *` 명령어를 써볼걸 그랬네요.

🧑🏻‍🔧 여기서 의문! 

그렇다면 `keys *` 명령어는 캐시 데이터가 몇 건정도 있어야 느린걸까요? 

🧑🏻‍🔧 여기서 또다른 의문! 

데이터가 엄청나게 많을 때는 `exists`와 같이 존재성 여부만 검사하거나, `keys [prefix]*`와 같이 접두사를 붙여서 조회할까요? 혹시 관련 경험 있으면 공유받고 싶습니다!


- **원인**

keys 명령어로 조회해보니, cafePreviewCache 데이터가 캐시에 남아있어서 캐시데이터를 바로 반환하는 현상 때문이었습니다. 캐시를 고려하지 못하고 RDBMS 내의 데이터만 삭제한 것이죠.
<img width="784" alt="image" src="https://github.com/TReKa-Genius-Library/redis-for-developer/assets/57135043/a6f87c7d-9b71-40b3-9edf-985d4f3832f8">

- 해결방법

`del` 명령어로 삭제해주었습니다~
<img width="482" alt="image" src="https://github.com/TReKa-Genius-Library/redis-for-developer/assets/57135043/37ffd338-0e59-4b5a-a6bf-fed80e7e2a45">

---

### 여기어때 - Redis&Kafka를 활용한 선착순 쿠폰 이벤트 개발기 (feat. 네고왕)
관련 글: https://techblog.gccompany.co.kr/redis-kafka%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%84%A0%EC%B0%A9%EC%88%9C-%EC%BF%A0%ED%8F%B0-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EA%B0%9C%EB%B0%9C%EA%B8%B0-feat-%EB%84%A4%EA%B3%A0%EC%99%95-ec6682e39731

- 요약

레디스는 싱글스레드 기반의 인메모리 DB이므로 선착순 쿠폰 발급 체계에 유리합니다. (빠르고, 싱글스레드이므로 동시성 이슈 방지할 수 있음.)
특히, `INCR` 커맨드를 통해 쿠폰 발급이 몇 건 됐는지 싱글스레드로 빠르게 처리할 수 있습니다.

하지만, 동시성 이슈가 아예 없는 것은 아닙니다.

<img width="702" alt="image" src="https://github.com/TReKa-Genius-Library/redis-for-developer/assets/57135043/8f59c12c-38d3-4243-b4b8-c8a8dba42f32">

위 사진과 같이, 여러 명령어가 하나의 단위로 처리돼야 하는데 그렇지 못하고 교차(?) 되는 경우에 동시성 이슈가 발생할 수 있습니다.
따라서 MULTI / EXEC 키워드를 이용하여 트랜잭션으로 묶어서 처리하는 사례입니다.

🧑🏻‍🔧 여기서 의문!

레디스의 트랜잭션은 [롤백이 꼭 필요하지 않은 경우가 많다고](https://redis.com/blog/you-dont-need-transaction-rollbacks-in-redis/) 해요.
이유가 뭘까? 또, 만약 롤백이 필요하다면 어떻게 해야될까?

🧑🏻‍🔧 여기서 의문!

다중 인스턴스다 하더라도, 싱글 스레드이기 때문에 트랜잭션을 적용한다면 동시성 이슈는 없을 것 같긴 합니다.
하지만 [비슷한 사례의 다른 글](https://dkswnkk.tistory.com/712)을 보면 분산락으로 해당 이슈를 해결한 사례도 존재하는데요.
어떤 방법이 더 나을지, 아니면 각각의 상황에 대한 장단점에 대해 얘기해봐도 좋을 거 같습니다.
