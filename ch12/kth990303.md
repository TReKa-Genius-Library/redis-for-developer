## 클라이언트 관리
### TCP 연결 대신 UNIX 소켓
- unixsocket, unixsocketperm 매개변수 설정
```
unixsocket /tmp/redis.sock
unixsocketperm 777
```
  - **Q. 책에서 안내돼있는 `unixsocketperm 777` 처럼 권한을 777로 줘도 괜찮을까?**
  - 참고: [redisgate 사이트](http://redisgate.jp/redis/server/redis_conf_han.php)에선 700 권한을 주고 있는 모습을 확인.
- 레디스의 멀티플렉싱 방식 - 하나의 스레드에서 여러 소켓 감시 및 확인, 논블라킹 I/O

### 클라이언트 버퍼 제한
- 출력 버퍼 크기에 제한을 둬서, 일정 수준 이상으로 크기가 커지면 클라이언트 연결을 종료함.
- 일반 클라이언트의 출력 버퍼 크기 제한은 0
  - 다음 커맨드를 보내기 전 응답을 받기를 기다리기 때문
- pub/sub 기본 하드 제한은 32MB, 소프트 제한 60초당 8MB
  - pub/sub은 빠르게 처리되는 메시지를 처리해야 하므로 더 많은 메모리 공간 요구
- 쿼리 버퍼: 클라이언트에서 받은 커맨드를 레디스에서 잠시 보관하는 내부 버퍼 역할
  - 출력 버퍼: 레디스 서버가 클라이언트에 응답을 보낼 때 사용하는 내부 버퍼
  - 레디스 서버에 커맨드가 전송되면, 서버는 이를 쿼리 버퍼에 저장한 뒤 처리
  - **Q. 쿼리 버퍼는 어떠한 때에 유용할까? 성능을 향상시키는 데에 초점이 맞춰져있을지, 백업 등 failover에 초점이 맞춰져있을지?**
  
### 클라이언트 이빅션
- 클라이언트 연결 수가 증가하면 메모리 사용량이 증가해 OOM 발생 가능 -> `maxmemory-clients` 모든 클라이언트 연결이 사용하는 누적 메모리양 제한 가능
  - maxmemory에 도달할 경우, 서버는 가장 많은 메모리를 사용하는 연결부터 해제하려고 시도
  - **Q. 해당 알고리즘을 바꿀 수 있을까? 과연 가장 많은 메모리를 사용하는 연결부터 끊는 것이 좋은걸까? **

### Timeout과 TCP Keepalive
- timeout 은 **응답이 없을때 얼마나 기다릴 것인가** 이고, KeepAlive 의 경우 **얼마나 길게 연결을 유지할 것인가** 설정임.
- 기본적인 timeout 설정값은 0
  - Q. timeout 설정 0이 과연 좋은 것일까?
  - A. 그렇진 않아보인다. redis timeout은 사내에서도 사용하고 있는 것으로 확인되며, LB, 애플리케이션 단에서 timeout 이 걸려있어 클라 입장에서 장애를 피할 수 있다 하더라도 redis에서 계속해서 기다리고 있으면 사용자 입장에서 원하는 응답을 받지 못하거나 응답을 계속 대기할 수 있을 듯.
- keep-alive 기본값은 300s 이나, 실제로는 더 짧게 가져가는 것도 좋아보임.

### 파이프라이닝
- 1200만 개의 키가 존재하는 레디스, 100만 개의 키를 가져온 후 키의 타입과 메모리 사용률을 확인하는 코드
  - batch size를 5000으로 한 결과 4시간에서 무려 3분 정도로 작업 완료 (142배의 성능 향상)
  - 단, 네트워크 대역폭을 고려하여 batch size를 너무 크게 설정하면 안됨.
 
### 사이드캐싱
- 캐싱 패턴으로 인해 데이터 정합성을 고려하고 처리해야 함 - `트래킹` 이라고 부름
  - default: 클라에서 엑세스한 키를 레디스 서버에서 기억. 동일 키가 수정될 경우 기억 무효화 (look aside 와 유사한 방식인듯)
  - broadcasting: 특정 프리픽스에 접근한 클라이언트만 기억. 메모리는 적게 사용하나 CPU를 더 많이 사용할 수 있음.
