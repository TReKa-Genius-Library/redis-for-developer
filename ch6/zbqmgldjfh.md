# 6. 레디스를 메시지 브로커로 사용하기

뭐랄까 아 그렇구나?~~ 하고 걍 슥 넘어가는 쳅터 느낌...
경험해본적이 없으니...

## 6.1 메시징큐 vs 스트림
1. 방향성의 차이
   메시징 큐는 생산자의 큐로 데이터를 직접 푸시한다. 따라서 동일 메시지를 서로 다른 사용자의 큐에 push해주어야 한다.

2. 영속성의 차이
   메시징 큐에서는 소비자가 데이터를 읽어갈때 삭제, 스트림에서는 구독자가 읽어간 데이터는 바로 삭제되지 않고, 저장소의 설정에 따라 특정 기간동안 저장될 수 있다.

메시징큐 방식 : (1:1) 상황에서, 즉 한서비스가 다른 서비스에게 동작을 지시하는경우 유리
메시지 브로커 방식 : (n:n) 상황에서 유리

## 6.2 레디스를 메시지 브로커로!
레디스의 pub/sub에서 모든 데이터는 한 번 채널 전체에 전파된 뒤 삭제되는 일회성의 특징을 가지며, 메시지가 잘 전달됐는지 등의 정보는 보장하지 않는다.

Redis의 list 자료구조는 메시징큐로 사용하기에 알맞다.
Redis의 stream은 아파치 카프타로부터 영감을 받음. 데이터가 계속 추가되는 방식의 append-only 방식

## 6.3 레디스의 pub/sub

레디스의 pub/sub은 매우 가볍기 때문에 최소한의 메시지 전달 기능만 제공한다.

`발행자` : 메시지를 채널로 보낼 수 있을 뿐, **어떤 구독자가 메시지를 읽어가는지, 정상적으로 모든 구독자에게 메시지가 전달됐는지 확인할 수 없다.**

`구독자` : 메시지를 받을 수 있지만 해당 메시지가 **언제 어떤 발행자에 의해 생성됐는지 등의 메타데이터는 알 수 없다.**

즉, 단순 통로로만 사용 -> 정합성이 중요한 경우에는 **부적합**

### 6-3-1) publish
```
> PUBLISH hello world
(integer) 1
```
위 명령어 수행시, hello라는 채널을 수신하고 있는 모든 서버들에 world라는 메시지를 전파

### 6-3-2) 구독
```
> SUBSCRIBE event1 event2
```
위 명령어 수행시, event1 과 event2 채널을 동시에 구독하기 시작.


```
> PSUBSCRIBE mail-*
```
위 명령어 수행시, 일치하는 패턴에 해당하는 채널을 한번에 구독할 수 있으며, 이때 Redis는 glob-style 패턴 지원

### 6-3-3) 클러스터 구조에서의 pub/sub
클러스터에서 메시지를 발행하면 해당 메시지는 클러스터에 속한 모든 노드에 자동으로 전달된다.
따라서 아무 노드에서나 SUBSCRIBE를 통해 구독했다면, 데이터를 수신할 수 있다.

다만 이 방식을 비효율적, `클러스터`는 데이터를 분산하기 위한 용도.
but, pub/sub에서는 모든 노드에 데이터가 복제되어버리는 일 발생.

이를 해결하기 위해 `shared pub/sub`이 7.0부터 생겨남

## 6.4 레디스의 List를 메시징 큐로 사용하기
list는 큐로 사용하기 적합한 자료구조.

### 6-4-1) List의 블로킹 기능
이벤트 기반 구조에서 시스템은 보통 이벤트 루프를 돌며 신규로 처리할 이벤트가 있는지 확인한다.

일정 시간동안 대기한 뒤 다시 이벤트 큐에 데이터가 있는지 확인하는 과정을 반복한다.
-> 불필요한 자원 소모,
-> 데이터가 추가되자마자 사용하는것이 아닌, 일정 시간 대기한뒤 폴링이 끝나야 처리됨

이런경우 list의 `블로킹 기능`사용한다면 이와 같은 불필요함을 줄일 수 있다.
`BRPOP`,  `BLPOP`은 RPOP, LPOP에 블로킹 기능을 추가한 커맨드이다.

BLPOP사용시 데이터가 없다면 일정시간 기다린 후 들어온값을 반환한다.

## 6.7 Stream
1. 백엔드 개발자들은 stream을 대량의 데이터를 효율적으로 처리하는 플랫폼으로 활용할 수 있다.
2. 데이터 엔지니어들은 stream을 여러 생산자가 생성한 데이터를 다양한 소비자가 처리할 수 있게 지원하는 데이터 저장소 및 중간 큐잉 시스템으로 사용할 수 있다.

### 6-7-1) 데이터 입력
다음은  레디스에서 stream을 생성하는 과정이다.
```
> XADD Email * subject "first" body "hello?"
"12314513611-0"
```

별도의 과정은 필요하지 않으며, XADD 커맨드를 이용해 새로운 이름의 stream에 데이터를 저장하면 데이터의 저장과 동시에 stream 자료구조가 생성된다.

위 명령어는 Email이라는 이름의 stream이 생성된다.
이때 사용한 * 는 저장되는 데이터의 ID를 의미하며, 이 값을 * 로 입력할 경우 레디스에서 자동 생성되는 타임스탬프 ID를 사용하겠다는 것을 의미한다.

또한 subject라는 키에 first라는 값을, body라는 키에 hello? 라는 값이 저장된다.

### 6-7-2) 데이터 조회
1. 카프카에서처럼 실시간으로 처리되는 데이터를 리스닝하는 것 가능
2. ID를 이용해 필요한 데이터를 검색하는 방식

### 6-7-3) 소비자와 소비자 그룹
stream의 데이터를 여러 소비자가 읽어가는 상황에 대하여 알아보자

같은 데이터를 여러 소비자에게 전달하는 것을 `fan-out`이라 부른다. 카프카에서는 같은 토픽을 여러 개의 소비자가 읽어가게 함으로써 간단하게 팬아웃 할 수 있다.

Redis 에서도 XREAD 명령어를 통하여 가능하다.

데이터 순서를 보장하는 방식으로,

**카프카**: 유니크 키가 파티션 내에서만 보장 - 소비자가 여러 파티션에서 토픽을 읽어갈때 순서보장되지 않음.
파티션 내부에서의 순서만 보장할 수 있음. -> 카프카는 순서보장하려면 소비자 그룹을 사용

**stream**: 고유 id - 순서를 항상 보장하며 래디스 stream에서의 소비자 그룹은, 다른 소비자가 아직 읽지 않은 데이터만을 읽어가도록 할 때 사용

- 부하분산의 관점
- 카프카는 파티션이라는 개념을 이용해 소비자의 부하를 관리
- stream은 파티션이라는 분할이 없어도 소비자그룹이라는 개념을 이용하여 여러 소비자에게 데이터를 분산

### 6-7-4) ACK와 보류 리스트
여러 서비스가 데이터를 처리할 때, 장애가 발생하는 경우 이를 인지하고 재처리 할 수 있는 기능이 필요하다.
즉, 각 브로커가 어느 데이터까지 전달했고, 전달된 메시지의 처리 유무를 인지하고 있어야 한다.

소비자가 메시지를 읽어갈떄, 메시지에 대한 리스트를 새로 생성하며, 마지막으로 읽어간 데이터의 ID를 last_delivered_id 값을 업데이트한다.

stream은 소비자별로 보류 리스트를 만들어, 어떤 소비자가 어떤 데이터를 읽어가는지 인식하고 있다.

특정 서버가 데이터를 받은경우 ACK 신호를 stream에 전달하고, 이를 받은 stream은 보유 리스트에서 이를 제거하여 성공적으로 전달해음을 확인한다.

- Redis Stream의 메시지 보증 전략
  - `at most once`: 메시지를 최소 한번 보내는 것. 소비자는 메시지를 받자마자 ACK를 응답
  - ACK를 보낸뒤 유실되면 일부 데이터 손실 가능
  - `at least once`: 메시지 모두 처리한 뒤 ack를 보낸다.
  - `exactly once`: 무조건 한번 전송받았다는 걸 보장한다는 의미로, 추가적인 기능이 필요할 수 있다.

### 6-7-5) 매시지 재할당
특정 서버가 터져서 복구가 안되면, 해당서버가 읽고 있던 메시지를 다른쪽으로 할당해야 한다.
`XCLAIM` 커맨드를 사용하여 가능하다.

EmailService3가 문제가 생겨, EmailService 1, 2가 가져가기 위해서는 XCLAIM 커맨드를 사용
```
EmailService 1: XCLAIM Email EmailServiceGroup EmailService3 3600000
123135413431-0
EmailService 2: XCLAIM Email EmailServiceGroup EmailService3 3600000
123135413431-0
```
email 서버 2의 명령어는 무시된다. -> 최소 대기 시간보다 메시지의 보류 시간이 짧기 때문

이를 자동으로 재할당 하는 `XAUTOCLAIM`이라는 커맨드도 있다.
