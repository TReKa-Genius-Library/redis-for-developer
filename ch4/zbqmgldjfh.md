# 4. 레디스 자료 구조 활용 사례
## 4-1) sorted set을 이용한 실시간 리더보드
리더보는 크게 2종류가 있다고 한다.
1) 절대적 리더 보드 : 모든 유저를 정렬시켜 상위권 목록만 표시
2) 상대적 리더 보드 : 사용자마다 다른 데이터를 보여줌, 사용자의 점수를 기반으로 비교해 순위를 결정하는 형태 -> **상대적인 성과**를 강조

레디스의 sorted set은 데이터가 저장될 때부터 정렬되어 들어간다.
-> sorted set의 가중치로 사용자의 스코어를 설정시, 데이터를 읽어올 때 매번 정렬할 필요가 없다.

기본적으로 Set이기 때문에 데이터가 중복되어 저장되지 않는다.
-> 같은 아이템을 저장하고자 할 때 Score가 다르면 기존 데이터의 스코어만 업데이트 된다.
```
(28점 - user:1) ---> ZADD daily-score:240115 200 user:1 ---> (200점 - user:1)
```


위처럼 직접 스코어를 "몇점"으로 지정하는 방식 말고,
`ZINCRBY` 이라는 명령어를 통해 sorted-set내의 스코어를 증가시킬 수 있다.
```
(28점 - user:1) ---> ZINCRBY daily-score:240115 100 user:1 ---> (128점 - user:1)
```


## 4-2) 랭킹 합산
일반적인 RDB : 특정 기간 데이터 조회 -> 합치는 과정 -> 정렬 후 -> 다시 영속화
Redis : `ZUNIONSTORE` 통한 간단한 구현 (바로 메모리에서 모두 처리됨)
`ZUNIONSTORE` 는 <생성할 키 이름><합산할 키 개수><합산할 키> ... 와 같이 사용

`ZUNIONSTORE` 는 합칠때 스코어에 가중치를 줄 수 도 있다.
명령어 마지막에 다음과 같이 가중치를 추가 : weights 1 1 1

```
ZUNIONSTORE weekly-score:2208-03 3 daily-score:15 daily-score:16 daily-score:17 weights 1 2 1
```

> Q: 특정 기간동안 포인트 2배 이벤트 같은점에 사용해보면 좋을수도??

## 4-3) 최근 검색 기록
이 기능을 RDB로 구현할 경우
데이터를 가져올 때 검색한 시점을 기준으로 sorting을 해야 하기 때문에 검색 기록이 늘어날수록 많은 데이터를 테이블에서 관리해야 한다는 문제 발생

### 핵심은 Score 대신 시간을 사용한다는 점~!!
직전의 랭킹은 Sorted Set에서 score에 점수를 사용했지만, 검색 기록의 경우 검색한 시간을 사용하면 된다.
이후 최근 검색 5건을 조회 하려면 이전처럼 `ZREVRANGE`를 사용하면 된다!
또한 애당초 Set이기 때문에 중복 저장에 대한 걱정을 할 필요가 없다!

## 4-4) sorted set을 활용한 태그 기능
테그 기능을
RDB 에서 구현 -> 태그 테이블, 태그-게시물 테이블 2개가 필요
Redis의 set 이용 -> 중복저장도 방지되고 별도의 테이블 불필요
```
SADD post:47:tags IT REDIS DataStore
3

SADD post:22:tags IT python
2
```

이후 일종의 `양방향 참조?`를 통하여 태그를 기준으로도 각 데이터를 저장할수 있다.
이경우 해당 태그와 관련된 포스트(게시글)들을 빠른시간 내로 찾기 수월 해 진다.

```
> SADD post:77:tags IT MySQL DataStore
3

> SADD post:IT:tags 77
1

> SADD post:MySQL:tags 77
1

> SADD post:DataStore:tags 77
1
```

이후 `SMEMBERS`커맨드를 통하여 특정 태그를 갖고 있는 포스트를 쉽게 찾을수가 있다.
```
> SMEMBERS tag:IT:posts
```

## 4-5) 랜덤 데이터 추출
보통 RDB 에서는 `ORDER BY RAND()`사용
-> 조건절에 맞는 모든 행을 읽은 뒤, 임시 테이블에 넣어 정렬한 다음 랜덤으로 limit에 해당할 때 까지 데이터를 추출한다. (데이터 >= 1만건 의 경우 성능 하락)

Redis 활용시 O(1) 시간 안에 랜덤한 데이터 추출 가능

`RANDOMKEY` 명령어는 Redis에 저장된 전체 키 중 하나를 무작위로 반환한다.
`HRANDFIELD`,  `SRANDMEMBER`, `ZRANDMEMBER` 는 각각 hash, set, sorted set에 저장된 아이템 중 랜덤한 아이템을 추출할 수 있다.

`HRANDFIELD`의 count 옵션의 경우
양수 -> 중복되지 않는 데이터를 반환
음수 -> 중복가능한 데이터 반환

```
> HRANDFIELD user:hash 2
1) "Id:4615"
2) "Id:134"

> HRANDFIELD user:hash -2
1) "Id:134"
2) "Id:134"
```

`WITHSCORE`옵션 사용시 필드에 연결된 값도 함께 반환

## 4-6) 레디스에서의 다양한 카운팅 방법
### 4-6-1) 좋아요 처리
1초에도 수만번 눌릴 수 있는 좋아요 수를, 누를 때 마다 RDB의 특정 행의 좋아요 수를 증가시키는 일은 RDB에 직접적인 영향을 미친다.

이 경우 Redis의 Set이 유용
해당 글의 좋아요에 Set을 생성후, 해당 Set에 좋아요를 누른 사람들의 ID를 저장해둠

### 4-6-2) 읽지 않은 메시지 수 카운팅
매번 RDB에 반영하는 것 이 아니라, 일단 Redis를 사용하여 일시적으로 저장한 후, 필요한 시점에 한번에 업데이트 하는 방식

이전의 좋아요와 다르게, 단순히 채널에 새로 추가된 메시지의 개수를 확인하면 된다.
사용자의 ID를 key로, 채널의 ID를 아이템의 key로 활용 (Hash 구조)
```
user:345 -> (channel:123) -> 3
         -> (channel:456) -> 77    
```
이런 방식

ID가 345인 사용자가 4234라는 새로운 채널에서 메시지를 받았다면
```
> HINCRBY user:345 channel:4234 1
(integer) 1
```

누군가 읽었다면 음수를 사용하여 감소시키는 방식
```
> HINCRBY user:345 channel:123 -1
(integer) 2
```

## 4-7) DAU 구하기
1) 사용자 접근 로그를 활용해 날마다 배치 처리를 통해 DAU를 구할 수 도 있음 (실시간성이 X)
2) 방문했던 user id를 Redis Set에 저장하는 방법 -> 하루 1000만명 이상 방문할 경우 너무 많은 키가 저장되어 성능 저하될 수 있다.(보통 키 하나당 아이템은 200~300만개 권장)
3) Redis의 bitmap을 이용시 메모리를 효율적으로 줄이면서 서비스 DAU 확인 가능
  1) 별도의 자료구조는 아니구, String 자료 구조에 bit연산을 수행
  2) 이때 사용자의 id는 정수값이어야 한다

사용자의 ID는 string의 하나의 비트로 표현할 수 있다.
1천만명 -> 1천만개의 비트로 표현 -> 이는 약 1.2MB의 크기에 해당

접속 유저의 ID를 1로 설정하면 된다. 14라는 ID의 사용자의 비트를 체크해보자
```
> SETBIT uv:20221106 14 1
```

해당 일자에 접근한 유저 수를 확인할 때에는 BITCOUNT 커맨드를 사용할 수 있다.
```
BITCOUNT uv:20221106
```

또한 bit 연산을 통해 특정 기간동안 매일 출석한 사용자를 확인할 수 있다! (대박....)

## 4-8) Geospatial Index를 이용한 위치 기반 애플리케이션
오?? Redis로 위치 계산을?

실시간으로 변화하는 사용자의 위치를 위하여
- 사용자의 현재 위치 파악
- 사용자의 이동에 따른 실시간 변동 위치 업데이트
- 사용자의 위치를 기준으로 근처의 장소 검색

하지만 이또한 사용자가 많다면 서버에 부하가 오는 작업이다.

### Redis에서의 위치 데이터
geo 자료구조를 통해 공간 정보를 처리할 수 있다.
메모리에서 처리 -> 빠른 계산 ->다른 저장소보다 효율적으로 처리 가능

이렇게 레디스 활용시 처리된 데이터의 이동에 따른 네트워크 트래픽을 감소시키고 애플리케이션 코드의 복잡성을 감소시킬 수 있으므로, 빠른 응답 속도를 보장한다.

또한 geo기능을 다른 기능과 연계가 가능한데,
<u>geo set과 pub/sub 사용시 특정 맛집에서 이벤트를 발생시킬 때 해당 지역 근처의 사용자에게 실시간 알림을 보내는 서비스를 간단하게(?ㅋㅋㅋ) 구축할 수 있다</u>

### geo set
geo set은 위치 공간 관리에 특화된 데이터 구조로, 각 위치 데이터는 경도, 위도 쌍으로 저장된다.

> Q : 와 인근 반경의 데이터 byradius로 한번에 조회된다는 점 정말 좋을거 같아요!~


관련 번역글 (글의 내용이 좋은데 아직 다 못 읽은)
https://blog.imqa.io/design_a_geo-spatial_index_3/
